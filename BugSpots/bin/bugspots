#!/usr/bin/env ruby

lib = File.expand_path(File.dirname(__FILE__) + '/../lib')
$LOAD_PATH.unshift(lib) if File.directory?(lib) && !$LOAD_PATH.include?(lib)

require 'bugspots'
require 'optparse'
require 'rainbow'
require 'rainbow/ext/string'
require "mongo"
require 'date'
include Mongo

today = DateTime.now

# Use your MongoDB Atlas connection string below:
mongo_uri = ENV['MONGO_URI'] || 'mongodb+srv://tayebwa:Tayebwa12.@opneelemetscluster.6u1np.mongodb.net/hieroTestTable?retryWrites=true&w=majority&tls=true&tlsAllowInvalidCertificates=true'
# Create a client using the connection string. The database is defined in the URI.
client = Mongo::Client.new(mongo_uri)

coll = client[:hieroTestTable]

ARGV << '--help' if ARGV.empty?

options = {}
OptionParser.new do |opts|
  opts.banner = "Usage: bugspots /path/to/git/repo"

  # Option: Set Branch
  opts.on('-b', '--branch [name]', 'branch to crawl') do |b|
    options[:branch] = b.to_s
  end

  # Option: Set Depth
  opts.on('-d', '--depth [depth]', 'depth of log crawl (integer)') do |d|
    options[:depth] = d.to_i
  end

  # Option: Set Bugfix Indicator
  opts.on('-w', '--words ["w1,w2"]', 'bugfix indicator word list, ie: "fixes,closed"') do |words|
    options[:regex] = Regexp.new(words.split(',').join('|'))
  end

  # Option: Set Bugfix Indicator
  opts.on('-r', '--regex [regex]', Regexp, 'bugfix indicator regex, ie: "fix(es|ed)?" or "/fixes #(\d+)/i"') do |regex|
    options[:regex] = regex
  end

  # Option: Set Limit
  opts.on('-l', '--limit [limit]', Integer, 'number of hotspots to display (default: 10)') do |limit|
    options[:limit] = limit.to_i
  end

  # Option: Set Timestamp Display
  opts.on('--display-timestamps', 'show timestamps of each identified fix commit') do |dt|
    options[:display_timestamps] = true
  end
end.parse!

# Set master as the default branch
options[:branch] ||= "master"
# Set default limit
options[:limit] ||= 10

begin
  fixes, spots, commits = Bugspots.scan(ARGV[0], options[:branch], options[:depth], options[:regex])
  
  fixes.each do |fix|
    next unless fix  # Skip nil entries

    message = "\t\t- "
    message << "#{fix.date} " if options[:display_timestamps] && fix.date
    message << "#{fix.message}" if fix.message
    # Uncomment the next line if you want to print the fixes:
    # puts message.foreground(:yellow)
  end

  puts "\n"
  puts "\tHotspots:".foreground(:green).underline
  # Apply limit to spots
  spots.take(options[:limit]).each do |spot|
    next unless spot.file && spot.score  # Add nil check for spot data
    
    puts "\t\t#{spot.score}".foreground(:red) + " - #{spot.file}".foreground(:yellow)
    doc = {
      "File"    => spot.file,
      "Score"   => spot.score,
      "Commits" => commits[spot.file],
      "Date"    => today.strftime("%d/%m/%Y %H:%M")
    }
    begin
      coll.insert_one(doc)
    rescue Mongo::Error::OperationFailure => e
      puts "Failed to insert document into MongoDB: #{e.message}"
    end
  end
rescue Rugged::RepositoryError
  puts "Invalid Git repository - please run from or specify the full path to the root of the project.".foreground(:red)
end
